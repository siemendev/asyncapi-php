<?php

namespace Siemendev\AsyncapiPhp\Generator;

use Nette\PhpGenerator\ClassType;
use Nette\PhpGenerator\PhpFile;
use Nette\PhpGenerator\Printer;
use Siemendev\AsyncapiPhp\Configuration\StubConfiguration;
use Siemendev\AsyncapiPhp\Message\AbstractMessage;
use Siemendev\AsyncapiPhp\Spec\Model\AsyncApi;
use Siemendev\AsyncapiPhp\Spec\Model\Message;
use Siemendev\AsyncapiPhp\Spec\Model\Reference;
use Siemendev\AsyncapiPhp\Spec\Model\Schema;
use Siemendev\AsyncapiPhp\Spec\ReferenceResolver;

class Generator
{
    public function generateStub(AsyncApi $spec, StubConfiguration $configuration): void
    {
        $this->ensureStubDirectory($configuration->getPath());
        $this->clearStubDirectory($configuration->getPath());

        $result = null;
        foreach ($this->extractMessages($spec) as $message) {
            $result = $this->generateClass($configuration, $spec, $message, $result);
        }

        foreach ($result->getFiles() as $fileName => $file) {
            $printer = new Printer();
            $printer->indentation = '    ';
            $printer->linesBetweenMethods = 1;

            file_put_contents($fileName, $printer->printFile($file));
        }
    }

    private function ensureStubDirectory(string $outputPath): void
    {
        if (!is_dir($outputPath) && !mkdir($outputPath, 0777, true) && !is_dir($outputPath)) {
            throw new \RuntimeException(sprintf('Directory "%s" was not created', $outputPath));
        }
    }

    private function clearStubDirectory(string $outputPath): void
    {
        if (!is_dir($outputPath)) {
            throw new \RuntimeException(sprintf('Directory "%s" does not exist', $outputPath));
        }
        $files = array_merge(
            glob($outputPath . DIRECTORY_SEPARATOR . '*.php'),
            glob($outputPath . DIRECTORY_SEPARATOR . '*' .DIRECTORY_SEPARATOR . '*.php')
        );
        foreach ($files as $file) {
            if (is_file($file) && str_contains(file_get_contents($file, length: 150), '@asyncapi-php-generated')) {
                unlink($file);
            }
        }
    }

    private function generateClass(
        StubConfiguration $configuration,
        AsyncApi $spec,
        Message $message,
        ?ClassGenerationResult $result = null,
    ): ClassGenerationResult {
        $result ??= new ClassGenerationResult();

        $className = ucfirst($message->getName()) . 'Message';
        $fileName = $configuration->getPath() . DIRECTORY_SEPARATOR . $className . '.php';

        if ($result->getFile($fileName) instanceof ClassType) {
            return $result;
        }

        $file = new PhpFile();
        $file->addComment('This file is @generated by AsyncAPI PHP Generator. Do not edit it manually. @asyncapi-php-generated');

        $class = $file->addClass($configuration->getNamespace() . '\\' . $className)
            ->setFinal(false)
            ->setExtends(AbstractMessage::class)
        ;

        $class->addMethod('getMessageName')
            ->setPublic()
            ->setStatic(true)
            ->setBody('return \'' . $message->getName() . '\';')
            ->setReturnType('string')
        ;

        $constructor = $class->addMethod('__construct')
            ->setBody('')
            ->setPublic()
        ;

        $requiredProperties = [];
        $optionalProperties = [];
        foreach ($message->getPayload()?->getProperties() as $name => $property) {
            if ($property instanceof Reference) {
                $property = ReferenceResolver::dereference($spec, $property, Schema::class);
            }

            $classProperty = $class->addProperty($name)
                ->setNullable(false)
                ->setPrivate()
            ;

            $getter = $class->addMethod('get' . ucfirst($name))
                ->setBody('return $this->' . $name . ';')
                ->setReturnNullable()
                ->setPublic()
            ;

            $setter = $class->addMethod('set' . ucfirst($name))
                ->setReturnType('self')
                ->setBody('$this->' . $name . ' = $' . $name . ';' . PHP_EOL . PHP_EOL .'return $this;')
                ->setPublic()
            ;
            $setterParameter = $setter->addParameter($name);

            // Handle types
            if ($type = $this->resolvePropertyType($property)) {
                $classProperty->setType($type);
                $getter->setReturnType($type);
                $setterParameter->setType($type);
            }

            // Handle nullable types
            if (in_array($name, $message->getPayload()?->getRequired() ?? [], true)) {
                $requiredProperties[] = $classProperty;
            } else {
                $optionalProperties[] = $classProperty;
                $classProperty->setNullable();
                $getter->setReturnNullable();
                $setterParameter->setNullable();
            }
        }

        foreach ($requiredProperties as $property) {
            $constructor->addParameter($property->getName())
                ->setType($property->getType())
                ->setNullable(false)
            ;
            $constructor->setBody(
                $constructor->getBody() . '$this->' . $property->getName() . ' = $' . $property->getName() . ';' . PHP_EOL
            );
        }
        foreach ($optionalProperties as $property) {
            $constructor->addParameter($property->getName())
                ->setType($property->getType())
                ->setNullable(true)
                ->setDefaultValue(null)
            ;
            $constructor->setBody(
                $constructor->getBody() . '$this->' . $property->getName() . ' = $' . $property->getName() . ';' . PHP_EOL
            );
        }

        return $result->addFile($fileName, $file);
    }

    /**
     * Extract messages from the AsyncAPI specification.
     *
     * @return Message[] An array of messages
     */
    private function extractMessages(AsyncApi $spec): array
    {
        $messages = [];

        foreach ($spec->getChannels() as $channel) {
            foreach ($channel->getMessages() as $message) {
                if ($message instanceof Message) {
                    $messages[] = $message;
                }
                if ($message instanceof Reference) {
                    $messages[] = ReferenceResolver::dereference($spec, $message, Message::class);
                }
            }
        }

        return $messages;
    }

    private function resolvePropertyType(Schema $schema): ?string
    {
        return match ($schema->getType()) {
            'string' => 'string',
            'integer' => 'int',
            'number', 'float' => 'float',
            'boolean' => 'bool',
            'array', 'object' => 'array',
            default => null,
        };
    }
}
